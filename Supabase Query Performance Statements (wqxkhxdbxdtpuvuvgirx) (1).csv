query,rolname,calls,mean_time,min_time,max_time,total_time,rows_read,cache_hit_rate,prop_total_time,index_advisor_result
"WITH pgrst_source AS (SELECT ""pgrst_call"".* FROM (SELECT $1 AS json_data) pgrst_payload, LATERAL (SELECT ""search_term"" FROM json_to_record(pgrst_payload.json_data) AS _(""search_term"" text) LIMIT $4) pgrst_body , LATERAL ""public"".""search_keywords_for_autocomplete""(""search_term"" := pgrst_body.""search_term"") pgrst_call) SELECT $5::bigint AS total_result_set, pg_catalog.count(_postgrest_t) AS page_total, coalesce(json_agg(_postgrest_t), $6) AS body, nullif(current_setting($7, $8), $9) AS response_headers, nullif(current_setting($10, $11), $12) AS response_status, $13 AS response_inserted FROM (SELECT ""record"".* FROM ""pgrst_source"" AS ""record""     LIMIT $2 OFFSET $3) _postgrest_t",authenticated,13570,67.5949831764186,18.167797,344.302168,917263.921704004,13570,100.0000000000000000,27.04323060750433,null
"WITH pgrst_source AS (SELECT ""pgrst_call"".* FROM (SELECT $1 AS json_data) pgrst_payload, LATERAL (SELECT ""search_term"" FROM json_to_record(pgrst_payload.json_data) AS _(""search_term"" text) LIMIT $4) pgrst_body , LATERAL ""public"".""check_keyword_match_fuzzy""(""search_term"" := pgrst_body.""search_term"") pgrst_call) SELECT $5::bigint AS total_result_set, pg_catalog.count(_postgrest_t) AS page_total, coalesce(json_agg(_postgrest_t), $6) AS body, nullif(current_setting($7, $8), $9) AS response_headers, nullif(current_setting($10, $11), $12) AS response_status, $13 AS response_inserted FROM (SELECT ""record"".* FROM ""pgrst_source"" AS ""record""     LIMIT $2 OFFSET $3) _postgrest_t",authenticated,14255,36.3813060094002,5.86957,424.803276,518615.517164,14255,99.9999021228094473,15.290080308884072,null
"with f as (
      
-- CTE with sane arg_modes, arg_names, and arg_types.
-- All three are always of the same length.
-- All three include all args, including OUT and TABLE args.
with functions as (
  select
    *,
    -- proargmodes is null when all arg modes are IN
    coalesce(
      p.proargmodes,
      array_fill($1::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])
    ) as arg_modes,
    -- proargnames is null when all args are unnamed
    coalesce(
      p.proargnames,
      array_fill($2::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])
    ) as arg_names,
    -- proallargtypes is null when all arg modes are IN
    coalesce(p.proallargtypes, p.proargtypes) as arg_types,
    array_cat(
      array_fill($3, array[pronargs - pronargdefaults]),
      array_fill($4, array[pronargdefaults])) as arg_has_defaults
  from
    pg_proc as p
  where
    p.prokind = $5
)
select
  f.oid as id,
  n.nspname as schema,
  f.proname as name,
  l.lanname as language,
  case
    when l.lanname = $6 then $7
    else f.prosrc
  end as definition,
  case
    when l.lanname = $8 then f.prosrc
    else pg_get_functiondef(f.oid)
  end as complete_statement,
  coalesce(f_args.args, $9) as args,
  pg_get_function_arguments(f.oid) as argument_types,
  pg_get_function_identity_arguments(f.oid) as identity_argument_types,
  f.prorettype as return_type_id,
  pg_get_function_result(f.oid) as return_type,
  nullif(rt.typrelid, $10) as return_type_relation_id,
  f.proretset as is_set_returning_function,
  case
    when f.provolatile = $11 then $12
    when f.provolatile = $13 then $14
    when f.provolatile = $15 then $16
  end as behavior,
  f.prosecdef as security_definer,
  f_config.config_params as config_params
from
  functions f
  left join pg_namespace n on f.pronamespace = n.oid
  left join pg_language l on f.prolang = l.oid
  left join pg_type rt on rt.oid = f.prorettype
  left join (
    select
      oid,
      jsonb_object_agg(param, value) filter (where param is not null) as config_params
    from
      (
        select
          oid,
          (string_to_array(unnest(proconfig), $17))[$18] as param,
          (string_to_array(unnest(proconfig), $19))[$20] as value
        from
          functions
      ) as t
    group by
      oid
  ) f_config on f_config.oid = f.oid
  left join (
    select
      oid,
      jsonb_agg(jsonb_build_object(
        $21, t2.mode,
        $22, name,
        $23, type_id,
        -- Cast null into false boolean
        $24, COALESCE(has_default, $25)
      )) as args
    from
      (
        select
          oid,
          unnest(arg_modes) as mode,
          unnest(arg_names) as name,
          -- Coming from: coalesce(p.proallargtypes, p.proargtypes) postgres won't automatically assume
          -- integer, we need to cast it to be properly parsed
          unnest(arg_types)::int8 as type_id,
          unnest(arg_has_defaults) as has_default
        from
          functions
      ) as t1,
      lateral (
        select
          case
            when t1.mode = $26 then $27
            when t1.mode = $28 then $29
            when t1.mode = $30 then $31
            when t1.mode = $32 then $33
            else $34
          end as mode
      ) as t2
    group by
      t1.oid
  ) f_args on f_args.oid = f.oid

    )
    select
      f.*
    from f
   where schema NOT IN ($35,$36,$37)

-- source: dashboard
-- user: d15152fa-178f-4302-bc9a-806a53ffcffd
-- date: 2025-05-21T03:10:41.809Z",postgres,1179,379.663443063613,123.991025,8073.292212,447623.199372,148736,100.0000000000000000,13.197049528992766,null
"WITH pgrst_source AS ( SELECT ""public"".""solutions"".""id"", ""public"".""solutions"".""title"", ""public"".""solutions"".""solution_category"" FROM ""public"".""solutions""  WHERE  ""public"".""solutions"".""title"" ilike $1 AND  ""public"".""solutions"".""is_approved"" = $2   LIMIT $3 OFFSET $4 )  SELECT $5::bigint AS total_result_set, pg_catalog.count(_postgrest_t) AS page_total, coalesce(json_agg(_postgrest_t), $6) AS body, nullif(current_setting($7, $8), $9) AS response_headers, nullif(current_setting($10, $11), $12) AS response_status, $13 AS response_inserted FROM ( SELECT * FROM pgrst_source ) _postgrest_t",authenticated,20615,19.7052319002667,0.306066,313.715257,406223.355624,20615,100.0000000000000000,11.976478769475753,null
"WITH pgrst_source AS (SELECT ""pgrst_call"".* FROM (SELECT $1 AS json_data) pgrst_payload, LATERAL (SELECT ""search_term"" FROM json_to_record(pgrst_payload.json_data) AS _(""search_term"" text) LIMIT $4) pgrst_body , LATERAL ""public"".""search_keywords_as_solutions""(""search_term"" := pgrst_body.""search_term"") pgrst_call) SELECT $5::bigint AS total_result_set, pg_catalog.count(_postgrest_t) AS page_total, coalesce(json_agg(_postgrest_t), $6) AS body, nullif(current_setting($7, $8), $9) AS response_headers, nullif(current_setting($10, $11), $12) AS response_status, $13 AS response_inserted FROM (SELECT ""record"".* FROM ""pgrst_source"" AS ""record""     LIMIT $2 OFFSET $3) _postgrest_t",authenticated,2834,120.480477475653,82.974272,454.453739,341441.673166,2834,100.0000000000000000,10.066553025749464,null
"WITH pgrst_source AS (UPDATE ""public"".""goal_implementation_links"" SET ""aggregated_fields"" = ""pgrst_body"".""aggregated_fields"", ""data_display_mode"" = ""pgrst_body"".""data_display_mode"", ""needs_aggregation"" = ""pgrst_body"".""needs_aggregation"", ""solution_fields"" = ""pgrst_body"".""solution_fields"", ""updated_at"" = ""pgrst_body"".""updated_at"" FROM (SELECT $1 AS json_data) pgrst_payload, LATERAL (SELECT ""aggregated_fields"", ""data_display_mode"", ""needs_aggregation"", ""solution_fields"", ""updated_at"" FROM json_to_record(pgrst_payload.json_data) AS _(""aggregated_fields"" jsonb, ""data_display_mode"" text, ""needs_aggregation"" boolean, ""solution_fields"" jsonb, ""updated_at"" timestamp with time zone) ) pgrst_body  WHERE  ""public"".""goal_implementation_links"".""id"" = $2 RETURNING $3) SELECT $4 AS total_result_set, pg_catalog.count(_postgrest_t) AS page_total, array[]::text[] AS header, $5::text AS body, nullif(current_setting($6, $7), $8) AS response_headers, nullif(current_setting($9, $10), $11) AS response_status, $12 AS response_inserted FROM (SELECT * FROM pgrst_source) _postgrest_t",service_role,15975,7.48337706078247,0.330328,194.208654,119546.948546,15975,99.9997008233341843,3.5245425241920536,null
"WITH pgrst_source AS ( SELECT ""public"".""goal_implementation_links"".""goal_id"" FROM ""public"".""goal_implementation_links""     LIMIT $1 OFFSET $2 )  SELECT $3::bigint AS total_result_set, pg_catalog.count(_postgrest_t) AS page_total, coalesce(json_agg(_postgrest_t), $4) AS body, nullif(current_setting($5, $6), $7) AS response_headers, nullif(current_setting($8, $9), $10) AS response_status, $11 AS response_inserted FROM ( SELECT * FROM pgrst_source ) _postgrest_t",service_role,70988,1.40629794386375,0.6666,127.170116,99830.2784390011,70988,100.0000000000000000,2.9432458614767834,null
"WITH pgrst_source AS ( SELECT ""public"".""goal_implementation_links"".""id"", ""public"".""goal_implementation_links"".""goal_id"", ""public"".""goal_implementation_links"".""implementation_id"", ""public"".""goal_implementation_links"".""aggregated_fields"", ""public"".""goal_implementation_links"".""solution_fields"", row_to_json(""goal_implementation_links_solution_variants_1"".*)::jsonb AS ""solution_variants"" FROM ""public"".""goal_implementation_links"" INNER JOIN LATERAL ( SELECT row_to_json(""solution_variants_solutions_2"".*)::jsonb AS ""solutions"" FROM ""public"".""solution_variants"" AS ""solution_variants_1"" INNER JOIN LATERAL ( SELECT ""solutions_2"".""title"", ""solutions_2"".""solution_category"" FROM ""public"".""solutions"" AS ""solutions_2""  WHERE ""solutions_2"".""id"" = ""solution_variants_1"".""solution_id""   LIMIT $1 OFFSET $2 ) AS ""solution_variants_solutions_2"" ON $8 WHERE ""solution_variants_1"".""id"" = ""public"".""goal_implementation_links"".""implementation_id""   LIMIT $3 OFFSET $4 ) AS ""goal_implementation_links_solution_variants_1"" ON $9 WHERE  ""public"".""goal_implementation_links"".""goal_id"" = $5   LIMIT $6 OFFSET $7 )  SELECT $10::bigint AS total_result_set, pg_catalog.count(_postgrest_t) AS page_total, coalesce(json_agg(_postgrest_t), $11) AS body, nullif(current_setting($12, $13), $14) AS response_headers, nullif(current_setting($15, $16), $17) AS response_status, $18 AS response_inserted FROM ( SELECT * FROM pgrst_source ) _postgrest_t",service_role,1970,32.7333880614213,0.119155,700.461305,64484.774481,1970,100.0000000000000000,1.9011721552538428,null
"WITH pgrst_source AS (SELECT ""pgrst_call"".* FROM (SELECT $1 AS json_data) pgrst_payload, LATERAL (SELECT ""timeframe_days"", ""limit_count"" FROM json_to_record(pgrst_payload.json_data) AS _(""timeframe_days"" integer, ""limit_count"" integer) LIMIT $4) pgrst_body , LATERAL ""public"".""get_trending_goals""(""timeframe_days"" := pgrst_body.""timeframe_days"", ""limit_count"" := pgrst_body.""limit_count"") pgrst_call) SELECT $5::bigint AS total_result_set, pg_catalog.count(_postgrest_t) AS page_total, coalesce(json_agg(_postgrest_t), $6) AS body, nullif(current_setting($7, $8), $9) AS response_headers, nullif(current_setting($10, $11), $12) AS response_status, $13 AS response_inserted FROM (SELECT ""record"".* FROM ""pgrst_source"" AS ""record""     LIMIT $2 OFFSET $3) _postgrest_t",authenticated,107,594.061884953271,9.08125,3414.12577,63564.62169,107,100.0000000000000000,1.8740437535666545,null
SELECT name FROM pg_timezone_names,authenticator,296,194.799534209459,56.275025,561.423732,57660.6621259999,353424,0,1.6999802847996386,null
"with f as (
      
-- CTE with sane arg_modes, arg_names, and arg_types.
-- All three are always of the same length.
-- All three include all args, including OUT and TABLE args.
with functions as (
  select
    *,
    -- proargmodes is null when all arg modes are IN
    coalesce(
      p.proargmodes,
      array_fill($1::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])
    ) as arg_modes,
    -- proargnames is null when all args are unnamed
    coalesce(
      p.proargnames,
      array_fill($2::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])
    ) as arg_names,
    -- proallargtypes is null when all arg modes are IN
    coalesce(p.proallargtypes, p.proargtypes) as arg_types,
    array_cat(
      array_fill($3, array[pronargs - pronargdefaults]),
      array_fill($4, array[pronargdefaults])) as arg_has_defaults
  from
    pg_proc as p
  where
    p.prokind = $5
)
select
  f.oid as id,
  n.nspname as schema,
  f.proname as name,
  l.lanname as language,
  case
    when l.lanname = $6 then $7
    else f.prosrc
  end as definition,
  case
    when l.lanname = $8 then f.prosrc
    else pg_get_functiondef(f.oid)
  end as complete_statement,
  coalesce(f_args.args, $9) as args,
  pg_get_function_arguments(f.oid) as argument_types,
  pg_get_function_identity_arguments(f.oid) as identity_argument_types,
  f.prorettype as return_type_id,
  pg_get_function_result(f.oid) as return_type,
  nullif(rt.typrelid, $10) as return_type_relation_id,
  f.proretset as is_set_returning_function,
  case
    when f.provolatile = $11 then $12
    when f.provolatile = $13 then $14
    when f.provolatile = $15 then $16
  end as behavior,
  f.prosecdef as security_definer,
  f_config.config_params as config_params
from
  functions f
  left join pg_namespace n on f.pronamespace = n.oid
  left join pg_language l on f.prolang = l.oid
  left join pg_type rt on rt.oid = f.prorettype
  left join (
    select
      oid,
      jsonb_object_agg(param, value) filter (where param is not null) as config_params
    from
      (
        select
          oid,
          (string_to_array(unnest(proconfig), $17))[$18] as param,
          (string_to_array(unnest(proconfig), $19))[$20] as value
        from
          functions
      ) as t
    group by
      oid
  ) f_config on f_config.oid = f.oid
  left join (
    select
      oid,
      jsonb_agg(jsonb_build_object(
        $21, t2.mode,
        $22, name,
        $23, type_id,
        -- Cast null into false boolean
        $24, COALESCE(has_default, $25)
      )) as args
    from
      (
        select
          oid,
          unnest(arg_modes) as mode,
          unnest(arg_names) as name,
          -- Coming from: coalesce(p.proallargtypes, p.proargtypes) postgres won't automatically assume
          -- integer, we need to cast it to be properly parsed
          unnest(arg_types)::int8 as type_id,
          unnest(arg_has_defaults) as has_default
        from
          functions
      ) as t1,
      lateral (
        select
          case
            when t1.mode = $26 then $27
            when t1.mode = $28 then $29
            when t1.mode = $30 then $31
            when t1.mode = $32 then $33
            else $34
          end as mode
      ) as t2
    group by
      t1.oid
  ) f_args on f_args.oid = f.oid

    )
    select
      f.*
    from f
   where schema NOT IN ($35,$36,$37)

-- source: dashboard
-- user: d15152fa-178f-4302-bc9a-806a53ffcffd
-- date: 2025-07-24T00:43:21.284Z",postgres,109,518.025879165138,188.432579,748.250677,56464.820829,18587,100.0000000000000000,1.6647238976251946,null
WITH    rows AS (      SELECT ctid      FROM net._http_response      WHERE created < now() - $1      ORDER BY created      LIMIT $2    )    DELETE FROM net._http_response r    USING rows WHERE r.ctid = rows.ctid,supabase_admin,3944419,0.0137872706284499,0.004167,8.096433,54382.7722250051,46,100.0000000000000000,1.603339906386045,null
"WITH pgrst_source AS (SELECT ""pgrst_call"".* FROM (SELECT $1 AS json_data) pgrst_payload, LATERAL (SELECT ""search_term"" FROM json_to_record(pgrst_payload.json_data) AS _(""search_term"" text) LIMIT $4) pgrst_body , LATERAL ""public"".""check_keyword_match""(""search_term"" := pgrst_body.""search_term"") pgrst_call) SELECT $5::bigint AS total_result_set, pg_catalog.count(_postgrest_t) AS page_total, coalesce(json_agg(_postgrest_t), $6) AS body, nullif(current_setting($7, $8), $9) AS response_headers, nullif(current_setting($10, $11), $12) AS response_status, $13 AS response_inserted FROM (SELECT ""text"".* FROM ""pgrst_source"" AS ""text""     LIMIT $2 OFFSET $3) _postgrest_t",authenticated,3790,9.26680048337729,6.16112,46.260111,35121.173832,3790,100.0000000000000000,1.035459894008035,null
"WITH    rows AS (      SELECT id      FROM net.http_request_queue      ORDER BY id      LIMIT $1    )    DELETE FROM net.http_request_queue q    USING rows WHERE q.id = rows.id    RETURNING q.id, q.method, q.url, timeout_milliseconds, array(select key || $2 || value from jsonb_each_text(q.headers)), q.body",supabase_admin,3944419,0.00888341259815416,0.002453,12.905618,35039.901437012,46,100.0000000000000000,1.0330637808854326,null
"WITH pgrst_source AS (SELECT ""pgrst_call"".* FROM (SELECT $1 AS json_data) pgrst_payload, LATERAL (SELECT ""timeframe_days"", ""limit_count"" FROM json_to_record(pgrst_payload.json_data) AS _(""timeframe_days"" integer, ""limit_count"" integer) LIMIT $4) pgrst_body , LATERAL ""public"".""get_trending_goals""(""timeframe_days"" := pgrst_body.""timeframe_days"", ""limit_count"" := pgrst_body.""limit_count"") pgrst_call) SELECT $5::bigint AS total_result_set, pg_catalog.count(_postgrest_t) AS page_total, coalesce(json_agg(_postgrest_t), $6) AS body, nullif(current_setting($7, $8), $9) AS response_headers, nullif(current_setting($10, $11), $12) AS response_status, $13 AS response_inserted FROM (SELECT ""record"".* FROM ""pgrst_source"" AS ""record""     LIMIT $2 OFFSET $3) _postgrest_t",anon,33,1033.55928133333,9.589038,2528.53782,34107.456284,33,100.0000000000000000,1.0055729696749485,null
"WITH pgrst_source AS (SELECT ""pgrst_call"".* FROM (SELECT $1 AS json_data) pgrst_payload, LATERAL (SELECT ""input_text"" FROM json_to_record(pgrst_payload.json_data) AS _(""input_text"" text) LIMIT $4) pgrst_body , LATERAL ""public"".""match_category_partial""(""input_text"" := pgrst_body.""input_text"") pgrst_call) SELECT $5::bigint AS total_result_set, pg_catalog.count(_postgrest_t) AS page_total, coalesce(json_agg(_postgrest_t), $6) AS body, nullif(current_setting($7, $8), $9) AS response_headers, nullif(current_setting($10, $11), $12) AS response_status, $13 AS response_inserted FROM (SELECT ""text"".* FROM ""pgrst_source"" AS ""text""     LIMIT $2 OFFSET $3) _postgrest_t",authenticated,1901,17.6841901704366,3.448206,53.483133,33617.645514,1901,100.0000000000000000,0.9911321252312446,null
"with tables as (SELECT
  c.oid :: int8 AS id,
  nc.nspname AS schema,
  c.relname AS name,
  c.relrowsecurity AS rls_enabled,
  c.relforcerowsecurity AS rls_forced,
  CASE
    WHEN c.relreplident = $1 THEN $2
    WHEN c.relreplident = $3 THEN $4
    WHEN c.relreplident = $5 THEN $6
    ELSE $7
  END AS replica_identity,
  pg_total_relation_size(format($8, nc.nspname, c.relname)) :: int8 AS bytes,
  pg_size_pretty(
    pg_total_relation_size(format($9, nc.nspname, c.relname))
  ) AS size,
  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,
  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,
  obj_description(c.oid) AS comment,
  coalesce(pk.primary_keys, $10) as primary_keys,
  coalesce(
    jsonb_agg(relationships) filter (where relationships is not null),
    $11
  ) as relationships
FROM
  pg_namespace nc
  JOIN pg_class c ON nc.oid = c.relnamespace
  left join (
    select
      table_id,
      jsonb_agg(_pk.*) as primary_keys
    from (
      select
        n.nspname as schema,
        c.relname as table_name,
        a.attname as name,
        c.oid :: int8 as table_id
      from
        pg_index i,
        pg_class c,
        pg_attribute a,
        pg_namespace n
      where
        i.indrelid = c.oid
        and c.relnamespace = n.oid
        and a.attrelid = c.oid
        and a.attnum = any (i.indkey)
        and i.indisprimary
    ) as _pk
    group by table_id
  ) as pk
  on pk.table_id = c.oid
  left join (
    select
      c.oid :: int8 as id,
      c.conname as constraint_name,
      nsa.nspname as source_schema,
      csa.relname as source_table_name,
      sa.attname as source_column_name,
      nta.nspname as target_table_schema,
      cta.relname as target_table_name,
      ta.attname as target_column_name
    from
      pg_constraint c
    join (
      pg_attribute sa
      join pg_class csa on sa.attrelid = csa.oid
      join pg_namespace nsa on csa.relnamespace = nsa.oid
    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)
    join (
      pg_attribute ta
      join pg_class cta on ta.attrelid = cta.oid
      join pg_namespace nta on cta.relnamespace = nta.oid
    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)
    where
      c.contype = $12
  ) as relationships
  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)
  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)
WHERE
  c.relkind IN ($13, $14)
  AND NOT pg_is_other_temp_schema(nc.oid)
  AND (
    pg_has_role(c.relowner, $15)
    OR has_table_privilege(
      c.oid,
      $16
    )
    OR has_any_column_privilege(c.oid, $17)
  )
group by
  c.oid,
  c.relname,
  c.relrowsecurity,
  c.relforcerowsecurity,
  c.relreplident,
  nc.nspname,
  pk.primary_keys
)
  
select
  *
  
from tables where schema IN ($18)",postgres,885,34.4911830429378,16.261466,209.756841,30524.696993,26482,99.9998253612536805,0.8999442804557105,null
SELECT name FROM pg_timezone_names,authenticator,173,160.258495179191,55.848489,1170.980298,27724.719666,206562,0,0.8173939579605463,null
"with
      tables as (SELECT
  c.oid :: int8 AS id,
  nc.nspname AS schema,
  c.relname AS name,
  c.relrowsecurity AS rls_enabled,
  c.relforcerowsecurity AS rls_forced,
  CASE
    WHEN c.relreplident = $1 THEN $2
    WHEN c.relreplident = $3 THEN $4
    WHEN c.relreplident = $5 THEN $6
    ELSE $7
  END AS replica_identity,
  pg_total_relation_size(format($8, nc.nspname, c.relname)) :: int8 AS bytes,
  pg_size_pretty(
    pg_total_relation_size(format($9, nc.nspname, c.relname))
  ) AS size,
  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,
  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,
  obj_description(c.oid) AS comment,
  coalesce(pk.primary_keys, $10) as primary_keys,
  coalesce(
    jsonb_agg(relationships) filter (where relationships is not null),
    $11
  ) as relationships
FROM
  pg_namespace nc
  JOIN pg_class c ON nc.oid = c.relnamespace
  left join (
    select
      table_id,
      jsonb_agg(_pk.*) as primary_keys
    from (
      select
        n.nspname as schema,
        c.relname as table_name,
        a.attname as name,
        c.oid :: int8 as table_id
      from
        pg_index i,
        pg_class c,
        pg_attribute a,
        pg_namespace n
      where
        i.indrelid = c.oid
        and c.relnamespace = n.oid
        and a.attrelid = c.oid
        and a.attnum = any (i.indkey)
        and i.indisprimary
    ) as _pk
    group by table_id
  ) as pk
  on pk.table_id = c.oid
  left join (
    select
      c.oid :: int8 as id,
      c.conname as constraint_name,
      nsa.nspname as source_schema,
      csa.relname as source_table_name,
      sa.attname as source_column_name,
      nta.nspname as target_table_schema,
      cta.relname as target_table_name,
      ta.attname as target_column_name
    from
      pg_constraint c
    join (
      pg_attribute sa
      join pg_class csa on sa.attrelid = csa.oid
      join pg_namespace nsa on csa.relnamespace = nsa.oid
    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)
    join (
      pg_attribute ta
      join pg_class cta on ta.attrelid = cta.oid
      join pg_namespace nta on cta.relnamespace = nta.oid
    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)
    where
      c.contype = $12
  ) as relationships
  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)
  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)
WHERE
  c.relkind IN ($13, $14)
  AND NOT pg_is_other_temp_schema(nc.oid)
  AND (
    pg_has_role(c.relowner, $15)
    OR has_table_privilege(
      c.oid,
      $16
    )
    OR has_any_column_privilege(c.oid, $17)
  )
group by
  c.oid,
  c.relname,
  c.relrowsecurity,
  c.relforcerowsecurity,
  c.relreplident,
  nc.nspname,
  pk.primary_keys
),
      columns as (-- Adapted from information_schema.columns

SELECT
  c.oid :: int8 AS table_id,
  nc.nspname AS schema,
  c.relname AS table,
  (c.oid || $18 || a.attnum) AS id,
  a.attnum AS ordinal_position,
  a.attname AS name,
  CASE
    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)
    ELSE $19
  END AS default_value,
  CASE
    WHEN t.typtype = $20 THEN CASE
      WHEN bt.typelem <> $21 :: oid
      AND bt.typlen = $22 THEN $23
      WHEN nbt.nspname = $24 THEN format_type(t.typbasetype, $25)
      ELSE $26
    END
    ELSE CASE
      WHEN t.typelem <> $27 :: oid
      AND t.typlen = $28 THEN $29
      WHEN nt.nspname = $30 THEN format_type(a.atttypid, $31)
      ELSE $32
    END
  END AS data_type,
  COALESCE(bt.typname, t.typname) AS format,
  a.attidentity IN ($33, $34) AS is_identity,
  CASE
    a.attidentity
    WHEN $35 THEN $36
    WHEN $37 THEN $38
    ELSE $39
  END AS identity_generation,
  a.attgenerated IN ($40) AS is_generated,
  NOT (
    a.attnotnull
    OR t.typtype = $41 AND t.typnotnull
  ) AS is_nullable,
  (
    c.relkind IN ($42, $43)
    OR c.relkind IN ($44, $45) AND pg_column_is_updatable(c.oid, a.attnum, $46)
  ) AS is_updatable,
  uniques.table_id IS NOT NULL AS is_unique,
  check_constraints.definition AS ""check"",
  array_to_json(
    array(
      SELECT
        enumlabel
      FROM
        pg_catalog.pg_enum enums
      WHERE
        enums.enumtypid = coalesce(bt.oid, t.oid)
        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)
      ORDER BY
        enums.enumsortorder
    )
  ) AS enums,
  col_description(c.oid, a.attnum) AS comment
FROM
  pg_attribute a
  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid
  AND a.attnum = ad.adnum
  JOIN (
    pg_class c
    JOIN pg_namespace nc ON c.relnamespace = nc.oid
  ) ON a.attrelid = c.oid
  JOIN (
    pg_type t
    JOIN pg_namespace nt ON t.typnamespace = nt.oid
  ) ON a.atttypid = t.oid
  LEFT JOIN (
    pg_type bt
    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid
  ) ON t.typtype = $47
  AND t.typbasetype = bt.oid
  LEFT JOIN (
    SELECT DISTINCT ON (table_id, ordinal_position)
      conrelid AS table_id,
      conkey[$48] AS ordinal_position
    FROM pg_catalog.pg_constraint
    WHERE contype = $49 AND cardinality(conkey) = $50
  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum
  LEFT JOIN (
    -- We only select the first column check
    SELECT DISTINCT ON (table_id, ordinal_position)
      conrelid AS table_id,
      conkey[$51] AS ordinal_position,
      substring(
        pg_get_constraintdef(pg_constraint.oid, $52),
        $53,
        length(pg_get_constraintdef(pg_constraint.oid, $54)) - $55
      ) AS ""definition""
    FROM pg_constraint
    WHERE contype = $56 AND cardinality(conkey) = $57
    ORDER BY table_id, ordinal_position, oid asc
  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum
WHERE
  NOT pg_is_other_temp_schema(nc.oid)
  AND a.attnum > $58
  AND NOT a.attisdropped
  AND (c.relkind IN ($59, $60, $61, $62, $63))
  AND (
    pg_has_role(c.relowner, $64)
    OR has_column_privilege(
      c.oid,
      a.attnum,
      $65
    )
  )
)
    select
      *,
      COALESCE(
  (
    SELECT
      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = tables.id)
    FROM
      columns
  ),
  $66
) AS columns
    from tables
where schema in ($67)

-- source: api
-- user: d15152fa-178f-4302-bc9a-806a53ffcffd
-- date: 2025-09-20T03:43:20.124Z",supabase_read_only_user,31,817.578765129032,599.568561,1126.530052,25344.941719,1508,100.0000000000000000,0.7472321623283598,null
"WITH pgrst_source AS ( SELECT ""public"".""goal_implementation_links"".""goal_id"", ""public"".""goal_implementation_links"".""aggregated_fields"", row_to_json(""goal_implementation_links_solution_variants_1"".*)::jsonb AS ""solution_variants"", row_to_json(""goal_implementation_links_goal_1"".*)::jsonb AS ""goal"" FROM ""public"".""goal_implementation_links"" INNER JOIN LATERAL ( SELECT row_to_json(""solution_variants_solutions_2"".*)::jsonb AS ""solutions"" FROM ""public"".""solution_variants"" AS ""solution_variants_1"" INNER JOIN LATERAL ( SELECT ""solutions_2"".""solution_category"" FROM ""public"".""solutions"" AS ""solutions_2""  WHERE  ""solutions_2"".""solution_category"" = ANY ($1)  AND ""solutions_2"".""id"" = ""solution_variants_1"".""solution_id""   LIMIT $2 OFFSET $3 ) AS ""solution_variants_solutions_2"" ON $11 WHERE ""solution_variants_1"".""id"" = ""public"".""goal_implementation_links"".""implementation_id""   LIMIT $4 OFFSET $5 ) AS ""goal_implementation_links_solution_variants_1"" ON $12 INNER JOIN LATERAL ( SELECT ""goals_1"".""title"" FROM ""public"".""goals"" AS ""goals_1""  WHERE ""goals_1"".""id"" = ""public"".""goal_implementation_links"".""goal_id""   LIMIT $6 OFFSET $7 ) AS ""goal_implementation_links_goal_1"" ON $13 WHERE  ""public"".""goal_implementation_links"".""data_display_mode"" = $8   LIMIT $9 OFFSET $10 )  SELECT $14::bigint AS total_result_set, pg_catalog.count(_postgrest_t) AS page_total, coalesce(json_agg(_postgrest_t), $15) AS body, nullif(current_setting($16, $17), $18) AS response_headers, nullif(current_setting($19, $20), $21) AS response_status, $22 AS response_inserted FROM ( SELECT * FROM pgrst_source ) _postgrest_t",service_role,38,612.102880578947,25.611826,2660.657058,23259.909462,38,100.0000000000000000,0.6857602055491291,null