#!/usr/bin/env node

/**
 * Lightweight orchestration for local/disposable Supabase instances used by tests.
 *
 * Usage:
 *  - node manage-supabase-test-db.js start  -> starts supabase, captures env, writes .env.test.local
 *  - node manage-supabase-test-db.js seed   -> runs test reset/setup against the active instance
 *  - node manage-supabase-test-db.js stop   -> stops supabase and cleans the containers
 *  - node manage-supabase-test-db.js status -> prints extracted Supabase env information
 */

const { spawnSync } = require('child_process');
const fs = require('fs');
const path = require('path');

const PROJECT_ROOT = path.resolve(__dirname, '../..');
const ENV_FILE = path.join(PROJECT_ROOT, '.env.test.local');
const REQUIRED_SUPABASE_ENV_KEYS = ['API_URL', 'ANON_KEY', 'SERVICE_ROLE_KEY'];
const DEFAULT_TEST_GOAL_ID = '56e2801e-0d78-4abd-a795-869e5b780ae7';

const [,, action] = process.argv;

if (!['start', 'seed', 'stop', 'status'].includes(action)) {
  console.error('Usage: node scripts/testing/manage-supabase-test-db.js <start|seed|stop|status>');
  process.exit(1);
}

function run(command, args, options = {}) {
  const result = spawnSync(command, args, {
    cwd: PROJECT_ROOT,
    stdio: options.stdio ?? 'inherit',
    encoding: options.encoding ?? 'utf-8',
    env: options.env ?? process.env,
  });

  if (result.error) {
    throw result.error;
  }

  if (typeof result.status === 'number' && result.status !== 0) {
    const output = [result.stdout, result.stderr].filter(Boolean).join('\n');
    throw new Error(`${command} ${args.join(' ')} failed with code ${result.status}\n${output}`);
  }

  return result;
}

function assertSupabaseCliAvailable() {
  try {
    run('supabase', ['--version'], { stdio: 'pipe' });
  } catch (error) {
    console.error('‚ùå Supabase CLI is required for disposable test databases.');
    console.error('   Install it from https://supabase.com/docs/guides/cli/start or ensure it is on your PATH.');
    process.exit(1);
  }
}

function parseSupabaseEnv(output) {
  const env = {};
  output.split(/\r?\n/).forEach(line => {
    const trimmed = line.trim();
    if (!trimmed || trimmed.startsWith('#')) return;
    const idx = trimmed.indexOf('=');
    if (idx === -1) return;
    const key = trimmed.slice(0, idx).trim();
    const value = trimmed.slice(idx + 1).trim();
    env[key] = value.replace(/^"|"$/g, '');
  });
  return env;
}

function readSupabaseEnv() {
  assertSupabaseCliAvailable();
  const result = run('supabase', ['status', '-o', 'env'], { stdio: 'pipe' });
  const env = parseSupabaseEnv(result.stdout || '');

  const missingKeys = REQUIRED_SUPABASE_ENV_KEYS.filter(key => !env[key]);
  if (missingKeys.length) {
    throw new Error(`Unable to read Supabase environment. Missing keys: ${missingKeys.join(', ')}`);
  }

  return env;
}

function formatValue(value) {
  if (value === undefined || value === null) return '';
  if (/^[A-Za-z0-9_:\/.\-]+$/.test(value)) return value;
  return JSON.stringify(value);
}

function mergeEnvFile(targetPath, updates) {
  let lines = [];
  if (fs.existsSync(targetPath)) {
    lines = fs.readFileSync(targetPath, 'utf-8').split(/\r?\n/);
  }

  const keyToIndex = new Map();
  lines.forEach((line, idx) => {
    const match = line.match(/^\s*([A-Za-z0-9_]+)\s*=/);
    if (match) {
      keyToIndex.set(match[1], idx);
    }
  });

  Object.entries(updates).forEach(([key, value]) => {
    if (!value) return;
    const formatted = `${key}=${formatValue(value)}`;
    if (keyToIndex.has(key)) {
      lines[keyToIndex.get(key)] = formatted;
    } else {
      lines.push(formatted);
    }
  });

  if (!lines.length) {
    lines.unshift('# Auto-generated by scripts/testing/manage-supabase-test-db.js');
  } else if (!lines[0].startsWith('# Auto-generated by scripts/testing/manage-supabase-test-db.js')) {
    lines.unshift('# Auto-generated by scripts/testing/manage-supabase-test-db.js');
  }

  fs.writeFileSync(targetPath, lines.join('\n'), 'utf-8');
}

function ensureEnvFile(env) {
  const updates = {
    NEXT_PUBLIC_SUPABASE_URL: env.API_URL,
    NEXT_PUBLIC_SUPABASE_ANON_KEY: env.ANON_KEY,
    SUPABASE_SERVICE_KEY: env.SERVICE_ROLE_KEY,
    TEST_GOAL_ID: process.env.TEST_GOAL_ID || DEFAULT_TEST_GOAL_ID,
    TEST_USER_EMAIL: process.env.TEST_USER_EMAIL || 'test@wwfm-platform.com',
    TEST_USER_PASSWORD: process.env.TEST_USER_PASSWORD || 'TestPassword123!'
  };

  mergeEnvFile(ENV_FILE, updates);
  console.log(`‚úÖ Wrote Supabase environment variables to ${path.relative(PROJECT_ROOT, ENV_FILE)}`);
  return updates;
}

function runTestProvisioning() {
  // Ensure the env file exists so the setup scripts can connect to the disposable instance.
  const supabaseEnv = readSupabaseEnv();
  ensureEnvFile(supabaseEnv);

  console.log('\nüßπ Cleaning any existing test data (local instance)...');
  run('npm', ['run', 'test:reset'], { stdio: 'inherit' });

  console.log('\nüå± Seeding fixtures via complete-test-setup.js...');
  run('npm', ['run', 'test:setup'], { stdio: 'inherit' });
}

try {
  switch (action) {
    case 'start': {
      assertSupabaseCliAvailable();
      console.log('üöÄ Starting local Supabase (disposable test instance)...');
      run('supabase', ['start'], { stdio: 'inherit' });
      const env = readSupabaseEnv();
      ensureEnvFile(env);
      console.log('Supabase local instance is ready.');
      break;
    }
    case 'seed': {
      runTestProvisioning();
      console.log('\n‚úÖ Test fixtures ready.');
      break;
    }
    case 'stop': {
      assertSupabaseCliAvailable();
      console.log('üõë Stopping local Supabase instance...');
      const stopArgs = ['stop'];
      run('supabase', stopArgs, { stdio: 'inherit' });
      console.log('Supabase containers stopped.');
      break;
    }
    case 'status': {
      const env = readSupabaseEnv();
      console.log('Supabase environment information:');
      Object.entries(env).forEach(([key, value]) => {
        console.log(`  ${key}=${value}`);
      });
      break;
    }
  }
} catch (error) {
  console.error(`\n‚ùå ${error.message}`);
  process.exit(1);
}
